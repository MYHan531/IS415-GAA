---
title: "Take-Home Exercise 1: Geospatial analytics for Social Good - Myanmar Arm Conflict Case Study"
title-block-banner: true
author: "Han Ming Yan"
date: 2024-09-02
date-modified: "last-modified"
format:
  html:
    toc: true
    toc-depth: 3
    toc-location: right
    number-sections: true
    number-depth: 3
    code-copy: true
    embed-resources: true
    lightbox: true
    lang: en
abstract: |
  In this study, you are tasked to apply spatial point patterns analysis methods to discover the spatial and spatio-temporal distribution of armed conflict in Myanmar.
keywords: ["Spatial Analysis", "Point Patterns", "First-Order Analysis", "Second-Order Analysis", "Monte Carlo simulation", "Myanmar", "Myanmar Civil War Crisis"]
---

# **Overview**

This exercise focuses on applying geospatial analytics to explore and analyze the impact of the armed conflict in Myanmar. The aim is to use spatial data and analytical techniques to better understand the conflict's dynamics, identify affected regions, and assess the humanitarian implications. This case study offers a real-world application of geospatial tools for social good, demonstrating how data-driven insights can inform decision-making in crisis situations.

## **Data used**

To provide answers to the questions above, the data set that will be used is:

-   ACLED_Myanmar.csv in the data folder

Tools used:

-   [**acledata**](https://acleddata.com/data-export-tool/) **requires Access Key, Given**

::: panel-tabset
## The Task

The specific tasks of this take-home exercise are as follows:

-   Using appropriate function of **sf** and **tidyverse** packages, import and transform the downloaded armed conflict data and administrative boundary data into sf tibble data.frames.

-   Using the geospatial data sets prepared, derive quarterly KDE layers.

-   Using the geospatial data sets prepared, perform 2nd-Order Spatial Point Patterns Analysis.

-   Using the geospatial data sets prepared, derive quarterly spatio-temporal KDE layers.

-   Using the geospatial data sets prepared, perform 2nd-Order Spatio-temporal Point Patterns Analysis.

-   Using appropriate **tmap** functions, display the KDE and Spatio-temporal KDE layers on openstreetmap of Myanmar.

-   Describe the spatial patterns revealed by the KDE and Spatio-temporal KDE maps.

## Grading Criteria

-   **Geospatial Data Wrangling (20 marks):** This is an important aspect of geospatial analytics. You will be assessed on your ability to employ appropriate R functions from various R packages specifically designed for modern data science such as readxl, tidyverse (tidyr, dplyr, ggplot2), sf just to mention a few of them, to perform the entire geospatial data wrangling processes, including. This is not limited to data import, data extraction, data cleaning and data transformation. Besides assessing your ability to use the R functions, this criterion also includes your ability to clean and derive appropriate variables to meet the analysis need.

<!-- -->

-   **Geospatial Analysis (30 marks):** In this exercise, you are expected to use the appropriate spatial point patterns analysis methods and R packages introduced in class to analysis the geospatial data prepared. You will be assessed on your ability to derive analytical products by using appropriate kernel estimation techniques.

-   **Geovisualisation and geocommunication (20 marks):** In this section, you will be assessed on your ability to communicate Exploratory Spatial Data Analysis and Confirmatory Spatial Data Analysis results in layman friendly visual representations. This course is geospatial centric, hence, it is important for you to demonstrate your competency in using appropriate geovisualisation techniques to reveal and communicate the findings of your analysis.

-   **Reproducibility (15 marks):** This is an important learning outcome of this exercise. You will be assessed on your ability to provide a comprehensive documentation of the analysis procedures in the form of code chunks of Quarto. It is important to note that it is not enough by merely providing the code chunk without any explanation on the purpose and R function(s) used.

-   **Bonus (15 marks):** Demonstrate your ability to employ methods beyond what you had learned in class to gain insights from the data.
:::

## **Installing and Loading the R packages**

In this hands-on exercise, five R packages will be used, they are:

-   [**sf**](https://r-spatial.github.io/sf/), a relatively new R package specially designed to import, manage and process vector-based geospatial data in R.

-   [**spatstat**](https://spatstat.org/), which has a wide range of useful functions for point pattern analysis. In this hands-on exercise, it will be used to perform 1st- and 2nd-order spatial point patterns analysis and derive kernel density estimation (KDE) layer.

-   sparr provides functions to estimate fixed and adaptive kernel

-   [**raster**](https://cran.r-project.org/web/packages/raster/) which reads, writes, manipulates, analyses and model of gridded spatial data (i.e. raster). In this hands-on exercise, it will be used to convert image output generate by spatstat into raster format.

-   [**maptools**](https://cran.r-project.org/web/packages/maptools/index.html) which provides a set of tools for manipulating geographic data. In this hands-on exercise, we mainly use it to convert *Spatial* objects into *ppp* format of **spatstat**. (Deprecated as of October 2023)

-   [**tmap**](https://cran.r-project.org/web/packages/tmap/index.html) which provides functions for plotting cartographic quality static point patterns maps or interactive maps by using [leaflet](https://leafletjs.com/) API.

Use the code chunk below to install and launch the five R packages.

# Issue 1: Installing maptools

**maptools** is retired as of October 2023 and binary is removed from CRAN. However, we can still download from [**Posit Public Package Manager**](https://packagemanager.posit.co/client/) snapshots by using the code chunk specified

```{r}
#|eval: false # it will no longer run anymore after first run
#|warning: false
install.packages("maptools", repos = "https://packagemanager.posit.co/cran/2023-10-13")
```

```{r}
pacman::p_load(tmap, sf, tidyverse, raster, spatstat, sp, sparr)
```

Since it is a .csv file, we will use readr::read_csv() to get the Myanmar data

```{r}
acled_sf <- readr::read_csv("data/myanmar/ACLED_Myanmar.csv") %>%
  st_as_sf(coords = c( "longitude","latitude"),
           crs = 4326) %>%
  st_transform(crs = 32647) %>%
    mutate(event_date = dmy(event_date))
```

```{r}
tmap_mode('plot') # interactive view
acled_sf %>% filter(year == 2023 |
                      event_type == 'Political Violence') %>%
  tm_shape() + 
  tm_dots()
tmap_mode('plot') # static view
```

## **Converting ACLED_sf frame to sp’s Spatial\* class**

```{r}
acled_myanmar <- as_Spatial(acled_sf)
```

## Display

```{r}
acled_myanmar
```

## Import the kml files

```{r}
adm0 <- st_read("data/myanmar/geonode-mmr_polbnda_adm0_250k_mimu_1.kml")
adm2 <- st_read("data/myanmar/geonode-mmr_polbnda_adm2_250k_mimu.kml")
adm3 <- st_read("data/myanmar/geonode-mmr_polbnda_adm3_250k_mimu_1.kml")
```

```{r}
# Convert event_date to quarters for quarterly analysis
acled_sf$quarter <- cut(acled_sf$event_date, breaks = "quarter")

```

```{r}
# Create a list to store KDEs for each quarter
kde_list <- list()
```

```{r}
# Loop through each quarter to create KDE layers
quarters <- unique(acled_sf$quarter)
for (q in quarters) {
  # Filter data for the current quarter
  acled_quarter <- acled_sf %>% filter(quarter == q)
  
  # Convert to spatstat ppp object
  ppp_data <- as.ppp(st_coordinates(acled_quarter), W = owin(c(min(st_coordinates(acled_sf)[,1]), max(st_coordinates(acled_sf)[,1])),
                                                            c(min(st_coordinates(acled_sf)[,2]), max(st_coordinates(acled_sf)[,2]))))
  
  # Derive KDE for this quarter
  kde <- density(ppp_data, sigma = bw.ppl(ppp_data))
  
  # Store KDE in the list
  kde_list[[as.character(q)]] <- kde
}
```

```{r}
# Display KDE for the first quarter as an example
plot(kde_list[[1]], main = paste("KDE for Quarter:", quarters[1]))
```

## **Converting the generic sp format into spatstat’s ppp format**

```{r}
acled_myanmar_ppp <- as.ppp(acled_sf)
acled_myanmar_ppp
```

```{r}
plot(acled_myanmar_ppp)
```

```{r}
summary(acled_myanmar_ppp)
```

```{r}
any(duplicated(acled_myanmar_ppp))
```

```{r}
sum(multiplicity(acled_myanmar_ppp) > 1)
```

# Second-order Spatial Point Patterns Analysis

## Computing kernel density estimation using automatic bandwidth selection method

```{r}
kde_mynamar_bw <- density(acled_myanmar_ppp, sigma=bw.diggle, edge=TRUE,
                          kernel="gaussian")
plot(kde_mynamar_bw)
```

```{r}
# bw is short form of Bandwidth
bw <- bw.diggle(acled_myanmar_ppp)
bw
```

#### Rescalling KDE values

```{r}
acled_myanmar_ppp.km <- rescale.ppp(acled_myanmar_ppp, 1000, "km")
kde_mynamar_bw <- density(acled_myanmar_ppp, sigma=bw.diggle, edge=TRUE,
                          kernel="gaussian")
plot(kde_mynamar_bw)
```

### **Different Automatic Bandwidth Methods**

```{r}
bw.CvL(acled_myanmar_ppp.km)
```

```{r}
bw.scott(acled_myanmar_ppp.km)
```

```{r}
bw.ppl(acled_myanmar_ppp.km)
```

```{r}
bw.diggle(acled_myanmar_ppp.km)
```

| Function  | Methodology                                | Advantages                                      | Limitations                                          |
|------------------|------------------|------------------|-------------------|
| bw.CvL    | Least Squares Cross-Validation             | Data-driven, adaptive                           | Computationally intensive, sensitive to outliers     |
| bw.scott  | Scott’s Rule of Thumb                      | Simple, quick                                   | Assumes Gaussian distribution, non-adaptive          |
| bw.ppl    | Penalized Profile Likelihood               | Balances fit and smoothness, flexible           | Complex, requires penalty parameter tuning           |
| bw.diggle | Diggle’s Method (Edge-corrected, adaptive) | Tailored for spatial data, handles edge effects | More specific, potentially computationally demanding |

-   **For Quick, General Estimates:** `bw.scott()` is suitable when you need a fast, rule-of-thumb bandwidth without deep customization.

-   **For Data-Driven Precision:** `bw.CvL()` offers a more tailored bandwidth selection by minimizing prediction error but at a higher computational cost.

-   **For Balancing Smoothness and Fit:** `bw.ppl()` is ideal when you want to control the trade-off between overfitting and oversmoothing.

-   **For Spatially Inhomogeneous Data with Edge Concerns:** `bw.diggle()` is preferable when dealing with spatial point patterns that exhibit varying intensities and are subject to boundary effects.

```{r}
acled_myanmar_ppl <- density(acled_myanmar_ppp.km, 
                               sigma=bw.ppl, 
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2))
plot(acled_myanmar.bw, main = "bw.diggle")
plot(acled_myanmar.ppl, main = "bw.ppl")
```

```{r}
par(mfrow=c(2,2))
plot(density(acled_myanmar_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="Gaussian")
plot(density(acled_myanmar_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="epanechnikov"), 
     main="Epanechnikov")
plot(density(acled_myanmar_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="quartic"), 
     main="Quartic")
plot(density(acled_myanmar_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="disc"), 
     main="Disc")
```

## G-Function Estimation and CSR Test

```{r}

G_conflict = Gest(acled_myanmar_ppp.km, correction = "border")
plot(G_conflict, main = "G-Function Estimation")

# Monte Carlo simulation test using G-function
G_conflict_csr <- envelope(acled_myanmar_ppp.km, Gest, nsim = 999)
plot(G_conflict_csr, main = "Monte Carlo Simulation - G-Function")

```

## **Fixed and Adaptive KDE**

### **Computing KDE by using fixed bandwidth**

```{r}
kde_myanmar_600 <- density(childcareSG_ppp.km, sigma=0.6, edge=TRUE, kernel="gaussian")
plot(kde_myanmar_600)
```

```{r}
kde_myanmar_adaptive <- adaptive.density(acled_myanmar_ppp.km, method="kernel")
plot(kde_myanmar_adaptive)
```

```{r}
gridded_kde_myanmar_bw <- as.SpatialGridDataFrame.im(kde_mynamar_bw)
spplot(gridded_kde_myanmar_bw)
```

#### Converting gridded output into raster

```{r}
kde_myanmar_bw_raster <- raster(kde_mynamar_bw)
```
